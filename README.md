# Структура сервиса gophermart 

## База данных

Сервис сохраняет данные в базу данных Postgres, схема данных приведена на рисунке:

![DB Scheme](https://raw.githubusercontent.com/SavchenkoIM/yapracticum-go-diploma-1/devbranch/doc/gophermart-schema.png)

Финансовая информация хранится как `bigint`, на стороне приложения go обрабатывается кастомным типом данных `Numeric`

Транзакции применяются в следующих случаях:  
— Для списания баллов. Изоляция: `Serializable`, 2 `SELECT` для проверки баланса, один `INSERT` для записи информации о списании  
— Для проверки баланса. Изоляция: `RepeatableRead`, 2 `SELECT` для проверки баланса

## Аутентификация

Аутентификация реализована через куки, в котором передаётся jwt токен с user_id (соответствует id пользователя из БД). Кроме этого в токене содержится случайное число, чтобы подписываемая информация была разной при каждой новой генерации токена.

Экспирация аутентификации обеспечивается на стороне сервера. При генерации токена, а также после каждого запроса пользователя время истечения принимается равным: текущее время + 5 минут.

Проверку аутентификации для нужных путей осуществляет middlware `CustomAuth`. В случае успешной аутентификации добавляется хэдер `LoggedUserID`, информацию из которого используют хэндлеры.

## Тестирование

Тестирование на данный момент реализовано на базе вебинара "продвинутое тестирование", тестируется непосредственно логика работы Storage.

## Опрос системы начисления баллов

Реализован в виде одной рутины, которая раз в 3 секуны проверяет базу на наличие необработанных записей, и если такие есть, последовательно для каждого заказа делает запрос в систему расчёта вознаграждения.

## TODO

— Лучше проработать разрешение конфликтов запросов. Транзакция не решает вопросы разграничения доступа к данным, а только предотвращает ошибочные ситуации в случае, когда по какой-то причине не удалось доступ правильно разграничить. То есть необходимо либо проводить повторные запросы в случаях ошибок транзакций, либо, что кажется лучшим решением, использовать мютекс для предотвращения одновременного проведения запросов, которые нельзя делать одновременно. Транзакции в таком случае будут нужны, кажется, только для подстраховки. Например, если почему-то запущен второй гофермарт.  

— Также надо в принципе лучше понять, каким образом транзакция блокирует записи. Например, если начать транзакцию с запроса к одной таблице, а затем сделать запрос к другой, то каким образом БД гарантирует, что данные во второй таблице с момента начала транзакции не изменились? Возможно, такая гарантия может быть только в случае, если изменение второй таблицы тоже проводится в рамках транзакции? В таком случае надо учитывать, что любые изменения этой таблицы необходимо оборачивать в транзакцию.  

— Проверка баланса путём чтения всех записей начисления и всех записей списания интуитивно выглядит очень медленной. Хорошо бы придумать механизм, который позволил бы получать данные одной строкой таблицы. Вот тут, кажется, как раз именно транзакции будут в тему.

— Надо как-то разделить сервис на несколько подсервисов, чтобы попробовать прикрытить RabbitMQ. Можно попробовать отдельно выделить аутентификацию, или написать лайт версию accrual.

— Прикрутить Clickhouse для логирования истории вызываемых хэндлеров.

— Если успею, разобраться с Redis и тем, как его можно применить для кэширования